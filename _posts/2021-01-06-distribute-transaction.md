---
title: 分布式事务常用解决方案和思路
description: 分布式事务常用解决方案和思路 
categories:
  - micro-service
tags:
  - distribute-transaction
---

分布式事务实现方案从类型上分：刚性事务，柔性事务。刚性事务指通常无业务改造，强一致性，原生支持回滚/隔离性，低并发，适合短事务。柔性事务，有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务。刚性事务有，[XA协](https://mp.weixin.qq.com/s/HUT_sGvIzoOjpVEONKy1Gg)议（[2pc](https://mp.weixin.qq.com/s/KlwOKC4XDJduUckDD4OhVg)， jta， jts），[3pc](https://mp.weixin.qq.com/s/Mb-sR70b-59DWqe6Bw3dfg)；柔性事务有，[tcc](https://mp.weixin.qq.com/s/e1tPlNVYgPVVAnbY2Tm3DQ)/fmt，[saga](https://mp.weixin.qq.com/s/HDSWK2eCOtusroV3Elv1jA)（状态机模式，aop模式），本地事务消息，[消息事务（半消息）](https://mp.weixin.qq.com/s/Vbff2ABVT1yqpBh_bxaVMA)，[最大努力通知事务消息](https://mp.weixin.qq.com/s/jDZ2HtkqiXRf9DKxNuDpGw)。

2pc是xa规范实现思路，xa规范是x/open dtp定义的交易中间件与数据库之间的接口规范，交易中间件用它来通知数据库事务的开始，结束，提交及回滚等。xa模型包括应用程序ap，事务管理器tm，资源管理器rm，通信资源管理器crm四部分，一般tm为交易中间件，rm为数据库，crm为消息中间件。

2pc通常使用到xa的tm，ap，rm。ap发起事务，通常为微服务自身，定义事务的边界，并访问事务边界内的资源；tm为事务协调方，事务操作总控，管理全局事务，分配事务唯一标识，监控事务执行进度，负责事务的提交，回滚，失败恢复等。rm本地事务资源，跟进协调方命令进行操作，管理本地共享资源（本地数据库）。

2pc分两个阶段，请求阶段和提交阶段。请求阶段tm串行给每个rm发送prepare消息，rm要么直接返回失败，要么在本地执行sql，记录事务日志（undo，redo），但不提交。提交阶段，如果tm收到了rm的失败消息或超时，直接给所有rm发送rollback消息；否则，发送commit消息，rm跟进tm的指令执行提交或者回滚操作。最后，释放所有事务处理过程中使用的锁资源。

2pc存在的问题：1，全流程同步阻塞，不管1阶段还是2阶段，所有参与节点都为事务阻塞型，当参与者占有公共资源时，其他三方访问公共资源可能不得不处于阻塞状态；2，tm单点故障，由于全流程依赖tm协调，一旦tm发生故障，参与者会一直阻塞下去，尤其在第二阶段，tm发生故障，所有参与者都处于锁定事务资源的状态中，而无法继续完成事务，所有参与者必须等tm重新上线才可继续工作；3，tm脑裂引起数据不一致，二阶段中，当tm向rm发送commit请求之后，发生了局部网络异常，或者在发送commit请求过程中tm发生故障，将会导致只有一部分rm接收到了commit请求，这部分rm接收到请求之后，执行commit，但其他未接收到commit请求的rm则无法执行事务提交，于是整个分布式系统出现了数据不一致；4，tm脑裂引起的事务状态不确定，tm在发出commit消息之后宕机，而接收到消息的rm同时也宕机了，那么即使通过选举协议产生了新的tm，事务的状态也是不确定的。

3pc是解决2pc的数据不一致和事务状态不确定问题而出现，3pc确保任何分支下的数据一致性，确保任何分支最多3次握手得到最终结果（超时机制），rm超时后的事务状态必须从tm获取，2pc只有tm超时机制，3pc增加了rm超时机制，一方面辅助解决2pc的事务问题，另外还能降低一定的同步阻塞问题。因为tm，rm的双向超时机制，所以3pc又被定义为“非阻塞”协议。

3pc分为三个阶段：准备阶段cancommit，对齐阶段precommit，提交阶段docommit。准备阶段，tm向rm发送commit请求，rm如果可以提交返回yes，否则no，询问超时默认rm为no，准备阶段只做sql处理，不记录事务日志。对齐阶段，tm通知各个rm事务最终状态，各个rm如果一致未收到事务对齐通知，会在超时后从tm反查事务状态，实现事务状态对齐，然后记录事务日志redo和undo。提交阶段，根据对齐阶段得到的事务状态结果，各rm根据tm的命令进行提交/abort或者超时后自动提交/abort。

分布式事务的触发场景大约有：1，跨数据库，数据库的物理分割下保障跨库操作的acid；2，跨服务，服务的网络分割下保障多服务的事务完整性。解决方案总体有：业务规避>base柔性事务>cp刚性事务。刚性事务首先有xa规范，xa规范的实现方案是2pc，开源框架有atomikos，bitronix，seata xa模型及各大数据库厂商对xa的落地。xa规范定义将事务的参与者分成了tm，ap和rm，并要求事务资源，如数据库，本身提供对规范和协议的支持，这样做的好处：1，可以从任何角度保证数据的隔离；2，实现数据的全局一致；3，对业务无侵入。

xa规范将事务机制落地到事务资源上面，使用的是xaconnection和xadatasource，两者均属于数据库驱动范围。如果框架自己实现，无法保证数据的兼容完整性，最佳实践需要数据资源，如数据库，本身提供对规范和协议的支持，seata xa模型也是如此。xa框架通过connection通讯层面去处置事务机制，避免sql相关处理，也利用了数据库内部xa实现，因此最能保证数据全局一致性。但也有如下缺陷：1，数据锁定，数据在事务未结束前，为了保障一致性，根据数据的隔离基本进行锁定；2，协议阻塞，本地事务在全局事务没有commit或callback前都是阻塞等待的；3，性能损耗高，主要体现在事务协调增加的rt（retry）成本，并发事务数据使用锁进行竞争阻塞。

刚性事务都是cp的，所以不可避免有性能上限，无法满足超高量级的互联网场景。因此出现了柔性事务，相对数据库的acid刚性事务，柔性事务本质是对xa协议的妥协，通过降低强一致性要求，从而降低数据库资源的锁定时间，提升可用性。其实就是基于base理论，保证数据的最终一致。

basically available，基本可用；soft state，柔性状态；eventually consistency最终一致性。基本可用指分布式系统出现不可知故障时，允许损失部分可用性。具体为，一响应时间的损失，通过延长响应时间（服务重试其他提供者）来保障可用性；二功能上的损失，流量高峰时，通过服务降级，限流等治理手段提供有损服务。柔性状态指允许系统的数据存在中间状态，并认为中间状态的存在不影响系统的整体可用，即允许系统在不同节点的数据副本之间进行数据同步的过程存在数据延时。最终一致性指系统中所有的数据副本，在经过一段时间的数据同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

柔性事务主要分为补偿型和通知型，补偿型又分为tcc，saga；通知型分mq事务消息，最大努力通知型。补偿型事务都是同步的，通知型则是异步的。

tcc是一种补偿型事务，它要求应用的每个服务提供try，confirm，cancel三个接口，其核心思想是通过对资源的预留（提供中间态，如账户状态、资金冻结等），尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留资源。tcc模型完全交由业务实现，每个子业务都需要实现try，confirm，cancel三个接口，对业务侵入大，资源锁定交由业务方。1，try，尝试执行业务，完成所有业务检查（一致性），预留必要的业务资源（准隔离性）；2，confirm，确认执行业务，不再做业务检查，只使用try阶段预留的业务资源，confirm操作满足幂等性；3，cancel，取消执行业务，释放try阶段预留业务资源。

2pc的操作对象在资源层，对开发人员无感知，而tcc的操作在于业务层，具有较高的开发成本；2pc是一个整体的长事务，也是刚性事务，而tcc是一组本地短性事务，是柔性事务；2pc的prepare表决阶段，进行了操作表决，而tcc的try阶段并没有表决准备，直接兼备资源操作与准备能力；2pc是全局锁定资源，所有参与者阻塞，交互等待tm通知，而tcc的资源锁定在于try操作，业务方可灵活选择业务资源的锁定粒度。

tcc为了解决网络不可靠引起的异常情况，要求业务方在设计上要遵循三个策略。1，允许空回滚，原因为异常发生在阶段一时，部分参与方没有收到try请求从而触发整个事务的cancel操作，try失败或者没有执行try操作的参与方收到cancel请求时，要进行空回滚操作；2，保持幂等性，原因是异常发生在第二阶段时，比如网络超时，则会重复调用参与方的confirm/cancel方法，因此confirm/cancel方法必须保持幂等性；3，防止资源悬挂，原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方侧try请求比cancel请求更晚到达的情况，cancel会执行空回滚而确保事务的正确性，但是此时try方法也不可以再被执行。

tcc对业务的侵入性强，使用成本非常昂贵，虽然提供了更灵活的资源锁粒度，比2pc有更高的吞吐量，当相对于2pc的强一致性，tcc的实施成本和数据一致性的牺牲带来的相对高吞吐量，总体表现出来的性价比较低，所以在成熟大厂中几乎没有使用。

saga模型是把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（对应tcc的confirm和cancel），当saga事务中任意一个本地事务出错时，可以调用相关的补偿方法恢复之前的事务，达到事务最终一致性。saga模型主要分，1，一串子事务（本地事务）的事务链；2，每个saga子事务tn都有对应的补偿定义cn用于撤销tn造成的结果；3，每个tn都没有预留动作，直接提交到库。执行顺序为t1-tn，或者中间j出错后撤销之前所有的t。数据的隔离性，通过业务层控制并发，在应用层加锁，应用层预先冻结资源等。恢复方式有，1，向后恢复，如任一子事务失败，则补偿所有已完成的事务；2，向前恢复，重试失败的事务，假设每个子事务最终都会成功。从saga模型定义中，其可以满足事务的三个特性，1，原子性，saga协调器协调事务链中的本地事务，要么全部提交，要么全部回滚；2，一致性，saga事务可以实现最终一致性；3，持久性，基于本地事务实现。saga无法保证外部的原子性和隔离性因为可以查看其他sagas的部分结果。

saga和tcc一样，都是强依靠业务改造，同样要求业务方在设计上遵循：允许空补偿，保持幂等性，防止资源悬挂；和tcc比，saga没有try，直接commit，所以会留下原始事务操作的痕迹，cancel属于不完美补偿，需要考虑对业务的影响。tcc的cancel是完美补偿的rollback，补偿操作会彻底清理之前的原始事务操作，用户是感知不到事务取消之前的状态信息。saga的补偿操作通常可以异步执行，tcc的cancel和confirm可以根据需要异步化。saga对业务侵入较小，只需要提供一个逆向操作的cancel即可，而tcc需要对业务进行进行全局性的流程改造。tcc最少通信次数为2n，而saga为n（n为子事务数量）。

目前业界saga的实现方式有：1，基于业务逻辑层proxy设计，基于aop实现，比如华为的servicecomb；2，状态机实现的机制，比如阿里的seata的saga模式。

aop proxy实现原理如下，业务逻辑层调用上加上事务注解`@Around("execution(* *(..)) &&* @annotation(TX)")`，proxy在真正业务逻辑被调用之前，生成一个全局唯一的 **txid** 标识事务组，txid保存在threadlocal变量里面，方法开始前写入，完成后清除，并向远端数据库写入txid，把事务组置为开始状态。业务逻辑层调用数据访问层之前，通过rpc proxy代理记录当前调用请求请求参数。如果业务正常，调用完成后，当前方法的调用记录存档或者删除，如果业务异常，查询调用链反向补偿。数据访问层设计，原始接口必须保证幂等性，提供补偿接口实现反向操作。这方面可以在框架层面做一些通用补偿实现，降低使用成本，补偿接口也必须是有幂等性保证。还可以提供补偿注解，基于原则接口方法，在方法名加注解标准补偿方法名：`@Compensable(cancelMethod='cancelRecord')`。补偿策略，首先调用执行失败，修改事务组状态；其次分布式事务补偿服务异步执行补偿。

状态机引擎[saga](https://mp.weixin.qq.com/s/HDSWK2eCOtusroV3Elv1jA)原理为，流程为先执行stateA，再执行stateB，然后stateC。状态执行是基于事件驱动的模型，stateA执行完成后，会产生路由消息放入EventQueue，事件消费端从EventQueue取出消息，执行stateB，在整个状态机启动时，会调用seata server开启分布式事务，并产生xid，然后记录“状态机实例”启动事件到本地数据库。当执行到一个“状态”时会调用seata server注册分支事务，并产生branchid，然后记录“状态实例”开始执行事件到本地数据库。当一个状态执行完成后，会记录“状态实例”执行结束事件到本地数据库，然后调用seata server上报分支事务的状态。当整个状态机执行完成，会记录“状态机实例”执行完成事件到本地数据库，然后调用seata server提交或者回滚分布式事务。

柔性事务包含补偿型事务和通知型事务。上面刨析了tcc和saga中的补偿事务。通知型事务主要包含事务消息和最大努力通知型分布式事务。通知型事务的核心思想是通过mq来通知其他事务参与者自己事务的执行状态。mq组件的引入有效将事务参与者解耦，各个参与者都可以异步执行，所以通知型事务又称异步事务。事务消息的难度在于服务本地事务和投递消息的一致性保障。目前业界的解决这个一致性的方案有：1，基于mq自身的事务消息方案；2，基于db的本地消息表方案。

基于mq的事务消息方案主要依靠mq的半消息机制来实现投递消息和参与者自身本地事务的一致性保障。半消息机制实现原理其实借鉴2pc的思路，是二阶段提交的广义拓展。其流程为：1，事务发起方首先发送prepare消息到mq；2，在发送prepare消息成功后，执行本地事务；3，根据本地事务执行结果返回commit或rollback；4，如果消息为rollback，mq将删除该prepare消息不进行下发，如果是commit，则mq将消息发送给consumer；5，如果执行本地事务过程中，执行端挂掉，或者超时，mq服务器端将不停询问producer来获取事务状态；6，consumer端的消费成功由mq保障。mq事务消息因为使用了半消息机制，对业务有较大侵入性。需注意：1，业务方调用半消息，并提供对应的回查方法；2，mq要提供半消息机制，并定期扫描长期半消息，对消息生产者进行回查确认事务；3，消费方需进行幂等消费。

有时我们的mq组件并不支持事务消息，或者我们想尽量减少业务侵入，我们可基于db本地消息表。1，业务方直接利用本地事务，将业务数据和事务消息直接写入数据库；2，投递线程，使用专门的投递线程进行事务消息投递到mq，根据投递ack去删除事务消息表记录。本地事务消息表的优势在于方案的通用性，无需提供回查方法，进一步减少业务侵入。在某些场景下，还可以利用注解等形式解耦，有可能实现无业务代码侵入式的实现。以下为一个企业级事务消息设计流程：1，事务消息服务，提供通用投递接口，用于保障事务消息的本地写入，并将事务消息写入事务内存队列；2，使用投递线程池，继续事务内存队列投递派发分配，投递工作线程只投递本实例拥有的事务消息，投递失败线程列入时间轮队列，重试机制使用失败挡位区分，默认提供6挡：5s、10s、15s、20s、25s、30s；3，时间轮线程进行60s转动，将到期的失败事务消息重入事务内存队列；4，因为我们的事务消息服务是无状态化的多实例存在，所以需要一个持锁线程进行主节点竞争抢锁，处理一些额外工作；5，因为我们的事务内存队列是内存级别的，不可避免面临重启等情况下的数据丢失，这时需要事务消息服务主节点进行定期扫表，将长期未投递的事务消息取出放入事务消息服务；6，事务消息服务主节点还有一个清理线程，专门用于将已处理成功的历史事务消息进行归档清理，降低db的数据量。

mq事务消息方案，需要mq支持半消息机制或者类似特性，在重复投递上具有较好的去重处理；需要业务方进行改造，提供对应的本地操作成功回查功能，具有较大的业务侵入。db本地事务消息表方案，使用数据库来存储事务消息，降低了对mq的需求，但增加了存储成本；事务消息使用了异步投递，增大了消息重复投递的可能性。两种事务消息的共性有，1，事务消息都依赖mq进行事务通知，所以都是异步的；2，事务消息在投递方都是存在重复投递的可能，需要有配套机制去降低重复投递率，实现更优好的消息投递去重；3，事务消息的消费方，因为投递重复的无可避免，因此需要进行消费去重设计或者服务幂等设计。

最大努力通知事务，其实现仍是基于mq进行事务控制。最大努力通知事务和事务消息都是通知型事务，主要适用于需要异步更新的数据，并对数据的实时性要求较低的场景。最大努力主要用于外部系统，因为外部网络更加复杂和不可信，故只能尽最大努力去通知实现数据的最终一致。而事务消息主要适用于内部系统的数据最终一致性保证，因为内部相对比较可控。两者的核心要点一致：保证参与者事务和消息的一致性投递。最大努力通知在消息的投递上面也有：1，基于mq自身的事务消息方案；2，基于db的本地事务消息表。

最大努力通知事务在投递之前和消息事务类似，关键在投递后处理，由于事务消息在于内部的事务处理，所以mq和系统是直连，并且无需严格的权限，安全等方面的思路设计。最大努力则在于第三方系统的对接，所以最大努力通知事务有以下的特性：1，业务主动方在完成业务处理后，向业务被动方（第三方系统）发送通知消息，允许存在消息丢失；2，业务主动方提供递增多挡位时间间隔（5min，10min，30min，1h，24h），用于失败重试调用业务被动方接口，在通知n次后不再通知，报警记录日志人工介入；3，业务被动方提供幂等的服务接口，防止通知重复消费；4，业务主动方需要有定期校验，对业务数据进行兜底，防止业务被动方无法履行责任时进行业务回滚，确保数据最终一致性。

从参与者来说，最大努力通知事务适用于跨平台，跨企业的系统间业务交互，事务消息更适用于同网络体系的内部服务交付；从消息层面来说，最大努力通知事务需要主动推送并提供多档次时间的重试机制来保证数据的通知，而事务消息只需要消息消费者主动消费；从数据层面来说，最大努力通知事务还需要额外的定期校验机制对数据进行兜底，保证数据的最终一致性，而事务消息只要保证消息的可靠投递即可，自身无需对数据进行兜底处理。最大努力通知事务本质是通过引入定期校验机制来对最终一致性兜底，对业务侵入较低，适合于对最终一致性敏感度比较低，业务链路较短的场景。

[saga](https://www.jianshu.com/p/e4b662407c66?from=timeline&isappinstalled=0) | [2pc&3pc](https://www.jianshu.com/p/dd6a340e50b2) | [tcc](https://www.cnblogs.com/jajian/p/10014145.html) | [xa](https://blog.csdn.net/wuzhiwei549/article/details/79925618) | [可靠消息最终一致性](https://www.cnblogs.com/haizai/p/11954339.html) | [seata设计原理](https://yq.aliyun.com/articles/715556?spm=a2c4e.11157919.spm-cont-list.23.3b31f2047Bulkr) | [seata](https://github.com/seata/seata) | [txc](http://arick.net/content/46) | [JTA原理与实现](https://developer.ibm.com/zh/articles/j-lo-jta/) | [xa of seata](http://seata.io/zh-cn/blog/seata-xa-introduce.html)
